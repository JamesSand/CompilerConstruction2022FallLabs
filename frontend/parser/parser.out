Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     type -> Int
Rule 3     program -> function_list
Rule 4     function_list -> declaration Semi function_list
Rule 5     function_list -> function function_list
Rule 6     function_list -> empty
Rule 7     function -> type Identifier LParen parameter_list RParen LBrace block RBrace
Rule 8     function -> type Identifier LParen parameter_list RParen Semi
Rule 9     parameter_list -> parameter Comma parameter_list
Rule 10    parameter_list -> parameter
Rule 11    parameter_list -> empty
Rule 12    parameter -> type Identifier
Rule 13    parameter -> type Identifier LBracket maybe_int RBracket
Rule 14    maybe_int -> Integer
Rule 15    maybe_int -> empty
Rule 16    block -> block block_item
Rule 17    block -> empty
Rule 18    block_item -> statement
Rule 19    block_item -> declaration Semi
Rule 20    statement -> statement_matched
Rule 21    statement -> statement_unmatched
Rule 22    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 23    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 24    statement_unmatched -> If LParen expression RParen statement
Rule 25    statement_matched -> While LParen expression RParen statement_matched
Rule 26    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 27    statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
Rule 28    statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
Rule 29    statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 30    statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 31    statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
Rule 32    statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
Rule 33    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 34    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 35    statement_unmatched -> Do statement_matched While LParen expression RParen Semi
Rule 36    statement_matched -> Continue Semi
Rule 37    statement_matched -> Return expression Semi
Rule 38    statement_matched -> opt_expression Semi
Rule 39    statement_matched -> LBrace block RBrace
Rule 40    statement_matched -> Break Semi
Rule 41    opt_expression -> expression
Rule 42    opt_expression -> empty
Rule 43    declaration -> type Identifier array
Rule 44    declaration -> type Identifier array Assign array_expression
Rule 45    array_expression -> LBrace array_expression_sub RBrace
Rule 46    array_expression_sub -> expression Comma array_expression_sub
Rule 47    array_expression_sub -> expression
Rule 48    array_sub -> empty
Rule 49    array_sub -> LBracket Integer RBracket array_sub
Rule 50    array -> LBracket Integer RBracket array_sub
Rule 51    declaration -> type Identifier
Rule 52    declaration -> type Identifier Assign expression
Rule 53    expression_list -> expression Comma expression_list
Rule 54    expression_list -> expression
Rule 55    expression_list -> empty
Rule 56    expression -> assignment
Rule 57    assignment -> conditional
Rule 58    conditional -> logical_or
Rule 59    logical_or -> logical_and
Rule 60    logical_and -> bit_or
Rule 61    bit_or -> xor
Rule 62    xor -> bit_and
Rule 63    bit_and -> equality
Rule 64    equality -> relational
Rule 65    relational -> additive
Rule 66    additive -> multiplicative
Rule 67    multiplicative -> unary
Rule 68    unary -> postfix
Rule 69    postfix -> primary
Rule 70    postfix -> Identifier LParen expression_list RParen
Rule 71    unary -> Minus unary
Rule 72    unary -> BitNot unary
Rule 73    unary -> Not unary
Rule 74    refer -> Identifier refer_arguments
Rule 75    refer_arguments -> LBracket expression RBracket refer_arguments
Rule 76    refer_arguments -> empty
Rule 77    assignment -> refer Assign expression
Rule 78    logical_or -> logical_or Or logical_and
Rule 79    logical_and -> logical_and And bit_or
Rule 80    bit_or -> bit_or BitOr xor
Rule 81    xor -> xor Xor bit_and
Rule 82    bit_and -> bit_and BitAnd equality
Rule 83    equality -> equality NotEqual relational
Rule 84    equality -> equality Equal relational
Rule 85    relational -> relational Less additive
Rule 86    relational -> relational Greater additive
Rule 87    relational -> relational LessEqual additive
Rule 88    relational -> relational GreaterEqual additive
Rule 89    additive -> additive Plus multiplicative
Rule 90    additive -> additive Minus multiplicative
Rule 91    multiplicative -> multiplicative Mul unary
Rule 92    multiplicative -> multiplicative Div unary
Rule 93    multiplicative -> multiplicative Mod unary
Rule 94    conditional -> logical_or Question expression Colon conditional
Rule 95    primary -> Integer
Rule 96    primary -> refer
Rule 97    primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 79
Assign               : 44 52 77
BitAnd               : 82
BitNot               : 72
BitOr                : 80
Break                : 40
Colon                : 94
Comma                : 9 46 53
Continue             : 36
Div                  : 92
Do                   : 33 34 35
Else                 : 22 23
Equal                : 84
For                  : 27 28 29 30 31 32
Greater              : 86
GreaterEqual         : 88
Identifier           : 7 8 12 13 43 44 51 52 70 74
If                   : 22 23 24
Int                  : 2
Integer              : 14 49 50 95
LBrace               : 7 39 45
LBracket             : 13 49 50 75
LParen               : 7 8 22 23 24 25 26 27 28 29 30 31 32 33 34 35 70 97
Less                 : 85
LessEqual            : 87
Minus                : 71 90
Mod                  : 93
Mul                  : 91
Not                  : 73
NotEqual             : 83
Or                   : 78
Plus                 : 89
Question             : 94
RBrace               : 7 39 45
RBracket             : 13 49 50 75
RParen               : 7 8 22 23 24 25 26 27 28 29 30 31 32 33 34 35 70 97
Return               : 37
Semi                 : 4 8 19 27 27 28 28 29 29 30 30 31 31 32 32 33 34 35 36 37 38 40
While                : 25 26 33 34 35
Xor                  : 81
error                : 

Nonterminals, with rules where they appear

additive             : 65 85 86 87 88 89 90
array                : 43 44
array_expression     : 44
array_expression_sub : 45 46
array_sub            : 49 50
assignment           : 56
bit_and              : 62 81 82
bit_or               : 60 79 80
block                : 7 16 39
block_item           : 16
conditional          : 57 94
declaration          : 4 19 28 30 32
empty                : 6 11 15 17 42 48 55 76
equality             : 63 82 83 84
expression           : 22 23 24 25 26 33 34 35 37 41 46 47 52 53 54 75 77 94 97
expression_list      : 53 70
function             : 5
function_list        : 3 4 5
logical_and          : 59 78 79
logical_or           : 58 78 94
maybe_int            : 13
multiplicative       : 66 89 90 91 92 93
opt_expression       : 27 27 27 28 28 29 29 29 30 30 31 31 31 32 32 38
parameter            : 9 10
parameter_list       : 7 8 9
postfix              : 68
primary              : 69
program              : 0
refer                : 77 96
refer_arguments      : 74 75
relational           : 64 83 84 85 86 87 88
statement            : 18 24
statement_matched    : 20 22 22 23 25 27 28 31 32 33 35
statement_unmatched  : 21 23 26 29 30 34
type                 : 7 8 12 13 43 44 51 52
unary                : 67 71 72 73 91 92 93
xor                  : 61 80 81

Parsing method: LALR

state 0

    (0) S' -> . program
    (3) program -> . function_list
    (4) function_list -> . declaration Semi function_list
    (5) function_list -> . function function_list
    (6) function_list -> . empty
    (43) declaration -> . type Identifier array
    (44) declaration -> . type Identifier array Assign array_expression
    (51) declaration -> . type Identifier
    (52) declaration -> . type Identifier Assign expression
    (7) function -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> . type Identifier LParen parameter_list RParen Semi
    (1) empty -> .
    (2) type -> . Int

    $end            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    program                        shift and go to state 1
    function_list                  shift and go to state 2
    declaration                    shift and go to state 3
    function                       shift and go to state 4
    empty                          shift and go to state 5
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (3) program -> function_list .

    $end            reduce using rule 3 (program -> function_list .)


state 3

    (4) function_list -> declaration . Semi function_list

    Semi            shift and go to state 8


state 4

    (5) function_list -> function . function_list
    (4) function_list -> . declaration Semi function_list
    (5) function_list -> . function function_list
    (6) function_list -> . empty
    (43) declaration -> . type Identifier array
    (44) declaration -> . type Identifier array Assign array_expression
    (51) declaration -> . type Identifier
    (52) declaration -> . type Identifier Assign expression
    (7) function -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> . type Identifier LParen parameter_list RParen Semi
    (1) empty -> .
    (2) type -> . Int

    $end            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    function                       shift and go to state 4
    function_list                  shift and go to state 9
    declaration                    shift and go to state 3
    empty                          shift and go to state 5
    type                           shift and go to state 6

state 5

    (6) function_list -> empty .

    $end            reduce using rule 6 (function_list -> empty .)


state 6

    (43) declaration -> type . Identifier array
    (44) declaration -> type . Identifier array Assign array_expression
    (51) declaration -> type . Identifier
    (52) declaration -> type . Identifier Assign expression
    (7) function -> type . Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> type . Identifier LParen parameter_list RParen Semi

    Identifier      shift and go to state 10


state 7

    (2) type -> Int .

    Identifier      reduce using rule 2 (type -> Int .)


state 8

    (4) function_list -> declaration Semi . function_list
    (4) function_list -> . declaration Semi function_list
    (5) function_list -> . function function_list
    (6) function_list -> . empty
    (43) declaration -> . type Identifier array
    (44) declaration -> . type Identifier array Assign array_expression
    (51) declaration -> . type Identifier
    (52) declaration -> . type Identifier Assign expression
    (7) function -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function -> . type Identifier LParen parameter_list RParen Semi
    (1) empty -> .
    (2) type -> . Int

    $end            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    declaration                    shift and go to state 3
    function_list                  shift and go to state 11
    function                       shift and go to state 4
    empty                          shift and go to state 5
    type                           shift and go to state 6

state 9

    (5) function_list -> function function_list .

    $end            reduce using rule 5 (function_list -> function function_list .)


state 10

    (43) declaration -> type Identifier . array
    (44) declaration -> type Identifier . array Assign array_expression
    (51) declaration -> type Identifier .
    (52) declaration -> type Identifier . Assign expression
    (7) function -> type Identifier . LParen parameter_list RParen LBrace block RBrace
    (8) function -> type Identifier . LParen parameter_list RParen Semi
    (50) array -> . LBracket Integer RBracket array_sub

    Semi            reduce using rule 51 (declaration -> type Identifier .)
    Assign          shift and go to state 13
    LParen          shift and go to state 14
    LBracket        shift and go to state 15

    array                          shift and go to state 12

state 11

    (4) function_list -> declaration Semi function_list .

    $end            reduce using rule 4 (function_list -> declaration Semi function_list .)


state 12

    (43) declaration -> type Identifier array .
    (44) declaration -> type Identifier array . Assign array_expression

    Semi            reduce using rule 43 (declaration -> type Identifier array .)
    Assign          shift and go to state 16


state 13

    (52) declaration -> type Identifier Assign . expression
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 18
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 14

    (7) function -> type Identifier LParen . parameter_list RParen LBrace block RBrace
    (8) function -> type Identifier LParen . parameter_list RParen Semi
    (9) parameter_list -> . parameter Comma parameter_list
    (10) parameter_list -> . parameter
    (11) parameter_list -> . empty
    (12) parameter -> . type Identifier
    (13) parameter -> . type Identifier LBracket maybe_int RBracket
    (1) empty -> .
    (2) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    type                           shift and go to state 39
    parameter_list                 shift and go to state 40
    parameter                      shift and go to state 41
    empty                          shift and go to state 42

state 15

    (50) array -> LBracket . Integer RBracket array_sub

    Integer         shift and go to state 43


state 16

    (44) declaration -> type Identifier array Assign . array_expression
    (45) array_expression -> . LBrace array_expression_sub RBrace

    LBrace          shift and go to state 45

    array_expression               shift and go to state 44

state 17

    (74) refer -> Identifier . refer_arguments
    (70) postfix -> Identifier . LParen expression_list RParen
    (75) refer_arguments -> . LBracket expression RBracket refer_arguments
    (76) refer_arguments -> . empty
    (1) empty -> .

    LParen          shift and go to state 47
    LBracket        shift and go to state 48
    Assign          reduce using rule 1 (empty -> .)
    Mul             reduce using rule 1 (empty -> .)
    Div             reduce using rule 1 (empty -> .)
    Mod             reduce using rule 1 (empty -> .)
    Plus            reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    Less            reduce using rule 1 (empty -> .)
    Greater         reduce using rule 1 (empty -> .)
    LessEqual       reduce using rule 1 (empty -> .)
    GreaterEqual    reduce using rule 1 (empty -> .)
    NotEqual        reduce using rule 1 (empty -> .)
    Equal           reduce using rule 1 (empty -> .)
    BitAnd          reduce using rule 1 (empty -> .)
    Xor             reduce using rule 1 (empty -> .)
    BitOr           reduce using rule 1 (empty -> .)
    And             reduce using rule 1 (empty -> .)
    Question        reduce using rule 1 (empty -> .)
    Or              reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    RBrace          reduce using rule 1 (empty -> .)
    RBracket        reduce using rule 1 (empty -> .)
    Colon           reduce using rule 1 (empty -> .)

    refer_arguments                shift and go to state 46
    empty                          shift and go to state 49

state 18

    (52) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 52 (declaration -> type Identifier Assign expression .)


state 19

    (56) expression -> assignment .

    Semi            reduce using rule 56 (expression -> assignment .)
    RParen          reduce using rule 56 (expression -> assignment .)
    Comma           reduce using rule 56 (expression -> assignment .)
    RBrace          reduce using rule 56 (expression -> assignment .)
    RBracket        reduce using rule 56 (expression -> assignment .)
    Colon           reduce using rule 56 (expression -> assignment .)


state 20

    (57) assignment -> conditional .

    Semi            reduce using rule 57 (assignment -> conditional .)
    RParen          reduce using rule 57 (assignment -> conditional .)
    Comma           reduce using rule 57 (assignment -> conditional .)
    RBrace          reduce using rule 57 (assignment -> conditional .)
    RBracket        reduce using rule 57 (assignment -> conditional .)
    Colon           reduce using rule 57 (assignment -> conditional .)


state 21

    (77) assignment -> refer . Assign expression
    (96) primary -> refer .

    Assign          shift and go to state 50
    Mul             reduce using rule 96 (primary -> refer .)
    Div             reduce using rule 96 (primary -> refer .)
    Mod             reduce using rule 96 (primary -> refer .)
    Plus            reduce using rule 96 (primary -> refer .)
    Minus           reduce using rule 96 (primary -> refer .)
    Less            reduce using rule 96 (primary -> refer .)
    Greater         reduce using rule 96 (primary -> refer .)
    LessEqual       reduce using rule 96 (primary -> refer .)
    GreaterEqual    reduce using rule 96 (primary -> refer .)
    NotEqual        reduce using rule 96 (primary -> refer .)
    Equal           reduce using rule 96 (primary -> refer .)
    BitAnd          reduce using rule 96 (primary -> refer .)
    Xor             reduce using rule 96 (primary -> refer .)
    BitOr           reduce using rule 96 (primary -> refer .)
    And             reduce using rule 96 (primary -> refer .)
    Question        reduce using rule 96 (primary -> refer .)
    Or              reduce using rule 96 (primary -> refer .)
    Semi            reduce using rule 96 (primary -> refer .)
    RParen          reduce using rule 96 (primary -> refer .)
    Comma           reduce using rule 96 (primary -> refer .)
    RBrace          reduce using rule 96 (primary -> refer .)
    RBracket        reduce using rule 96 (primary -> refer .)
    Colon           reduce using rule 96 (primary -> refer .)


state 22

    (58) conditional -> logical_or .
    (94) conditional -> logical_or . Question expression Colon conditional
    (78) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 58 (conditional -> logical_or .)
    RParen          reduce using rule 58 (conditional -> logical_or .)
    Comma           reduce using rule 58 (conditional -> logical_or .)
    RBrace          reduce using rule 58 (conditional -> logical_or .)
    RBracket        reduce using rule 58 (conditional -> logical_or .)
    Colon           reduce using rule 58 (conditional -> logical_or .)
    Question        shift and go to state 51
    Or              shift and go to state 52


state 23

    (59) logical_or -> logical_and .
    (79) logical_and -> logical_and . And bit_or

    Question        reduce using rule 59 (logical_or -> logical_and .)
    Or              reduce using rule 59 (logical_or -> logical_and .)
    Semi            reduce using rule 59 (logical_or -> logical_and .)
    RParen          reduce using rule 59 (logical_or -> logical_and .)
    Comma           reduce using rule 59 (logical_or -> logical_and .)
    RBrace          reduce using rule 59 (logical_or -> logical_and .)
    RBracket        reduce using rule 59 (logical_or -> logical_and .)
    Colon           reduce using rule 59 (logical_or -> logical_and .)
    And             shift and go to state 53


state 24

    (60) logical_and -> bit_or .
    (80) bit_or -> bit_or . BitOr xor

    And             reduce using rule 60 (logical_and -> bit_or .)
    Question        reduce using rule 60 (logical_and -> bit_or .)
    Or              reduce using rule 60 (logical_and -> bit_or .)
    Semi            reduce using rule 60 (logical_and -> bit_or .)
    RParen          reduce using rule 60 (logical_and -> bit_or .)
    Comma           reduce using rule 60 (logical_and -> bit_or .)
    RBrace          reduce using rule 60 (logical_and -> bit_or .)
    RBracket        reduce using rule 60 (logical_and -> bit_or .)
    Colon           reduce using rule 60 (logical_and -> bit_or .)
    BitOr           shift and go to state 54


state 25

    (61) bit_or -> xor .
    (81) xor -> xor . Xor bit_and

    BitOr           reduce using rule 61 (bit_or -> xor .)
    And             reduce using rule 61 (bit_or -> xor .)
    Question        reduce using rule 61 (bit_or -> xor .)
    Or              reduce using rule 61 (bit_or -> xor .)
    Semi            reduce using rule 61 (bit_or -> xor .)
    RParen          reduce using rule 61 (bit_or -> xor .)
    Comma           reduce using rule 61 (bit_or -> xor .)
    RBrace          reduce using rule 61 (bit_or -> xor .)
    RBracket        reduce using rule 61 (bit_or -> xor .)
    Colon           reduce using rule 61 (bit_or -> xor .)
    Xor             shift and go to state 55


state 26

    (62) xor -> bit_and .
    (82) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 62 (xor -> bit_and .)
    BitOr           reduce using rule 62 (xor -> bit_and .)
    And             reduce using rule 62 (xor -> bit_and .)
    Question        reduce using rule 62 (xor -> bit_and .)
    Or              reduce using rule 62 (xor -> bit_and .)
    Semi            reduce using rule 62 (xor -> bit_and .)
    RParen          reduce using rule 62 (xor -> bit_and .)
    Comma           reduce using rule 62 (xor -> bit_and .)
    RBrace          reduce using rule 62 (xor -> bit_and .)
    RBracket        reduce using rule 62 (xor -> bit_and .)
    Colon           reduce using rule 62 (xor -> bit_and .)
    BitAnd          shift and go to state 56


state 27

    (63) bit_and -> equality .
    (83) equality -> equality . NotEqual relational
    (84) equality -> equality . Equal relational

    BitAnd          reduce using rule 63 (bit_and -> equality .)
    Xor             reduce using rule 63 (bit_and -> equality .)
    BitOr           reduce using rule 63 (bit_and -> equality .)
    And             reduce using rule 63 (bit_and -> equality .)
    Question        reduce using rule 63 (bit_and -> equality .)
    Or              reduce using rule 63 (bit_and -> equality .)
    Semi            reduce using rule 63 (bit_and -> equality .)
    RParen          reduce using rule 63 (bit_and -> equality .)
    Comma           reduce using rule 63 (bit_and -> equality .)
    RBrace          reduce using rule 63 (bit_and -> equality .)
    RBracket        reduce using rule 63 (bit_and -> equality .)
    Colon           reduce using rule 63 (bit_and -> equality .)
    NotEqual        shift and go to state 57
    Equal           shift and go to state 58


state 28

    (64) equality -> relational .
    (85) relational -> relational . Less additive
    (86) relational -> relational . Greater additive
    (87) relational -> relational . LessEqual additive
    (88) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 64 (equality -> relational .)
    Equal           reduce using rule 64 (equality -> relational .)
    BitAnd          reduce using rule 64 (equality -> relational .)
    Xor             reduce using rule 64 (equality -> relational .)
    BitOr           reduce using rule 64 (equality -> relational .)
    And             reduce using rule 64 (equality -> relational .)
    Question        reduce using rule 64 (equality -> relational .)
    Or              reduce using rule 64 (equality -> relational .)
    Semi            reduce using rule 64 (equality -> relational .)
    RParen          reduce using rule 64 (equality -> relational .)
    Comma           reduce using rule 64 (equality -> relational .)
    RBrace          reduce using rule 64 (equality -> relational .)
    RBracket        reduce using rule 64 (equality -> relational .)
    Colon           reduce using rule 64 (equality -> relational .)
    Less            shift and go to state 59
    Greater         shift and go to state 60
    LessEqual       shift and go to state 61
    GreaterEqual    shift and go to state 62


state 29

    (65) relational -> additive .
    (89) additive -> additive . Plus multiplicative
    (90) additive -> additive . Minus multiplicative

    Less            reduce using rule 65 (relational -> additive .)
    Greater         reduce using rule 65 (relational -> additive .)
    LessEqual       reduce using rule 65 (relational -> additive .)
    GreaterEqual    reduce using rule 65 (relational -> additive .)
    NotEqual        reduce using rule 65 (relational -> additive .)
    Equal           reduce using rule 65 (relational -> additive .)
    BitAnd          reduce using rule 65 (relational -> additive .)
    Xor             reduce using rule 65 (relational -> additive .)
    BitOr           reduce using rule 65 (relational -> additive .)
    And             reduce using rule 65 (relational -> additive .)
    Question        reduce using rule 65 (relational -> additive .)
    Or              reduce using rule 65 (relational -> additive .)
    Semi            reduce using rule 65 (relational -> additive .)
    RParen          reduce using rule 65 (relational -> additive .)
    Comma           reduce using rule 65 (relational -> additive .)
    RBrace          reduce using rule 65 (relational -> additive .)
    RBracket        reduce using rule 65 (relational -> additive .)
    Colon           reduce using rule 65 (relational -> additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 30

    (66) additive -> multiplicative .
    (91) multiplicative -> multiplicative . Mul unary
    (92) multiplicative -> multiplicative . Div unary
    (93) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 66 (additive -> multiplicative .)
    Minus           reduce using rule 66 (additive -> multiplicative .)
    Less            reduce using rule 66 (additive -> multiplicative .)
    Greater         reduce using rule 66 (additive -> multiplicative .)
    LessEqual       reduce using rule 66 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 66 (additive -> multiplicative .)
    NotEqual        reduce using rule 66 (additive -> multiplicative .)
    Equal           reduce using rule 66 (additive -> multiplicative .)
    BitAnd          reduce using rule 66 (additive -> multiplicative .)
    Xor             reduce using rule 66 (additive -> multiplicative .)
    BitOr           reduce using rule 66 (additive -> multiplicative .)
    And             reduce using rule 66 (additive -> multiplicative .)
    Question        reduce using rule 66 (additive -> multiplicative .)
    Or              reduce using rule 66 (additive -> multiplicative .)
    Semi            reduce using rule 66 (additive -> multiplicative .)
    RParen          reduce using rule 66 (additive -> multiplicative .)
    Comma           reduce using rule 66 (additive -> multiplicative .)
    RBrace          reduce using rule 66 (additive -> multiplicative .)
    RBracket        reduce using rule 66 (additive -> multiplicative .)
    Colon           reduce using rule 66 (additive -> multiplicative .)
    Mul             shift and go to state 65
    Div             shift and go to state 66
    Mod             shift and go to state 67


state 31

    (71) unary -> Minus . unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    unary                          shift and go to state 68
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 32

    (67) multiplicative -> unary .

    Mul             reduce using rule 67 (multiplicative -> unary .)
    Div             reduce using rule 67 (multiplicative -> unary .)
    Mod             reduce using rule 67 (multiplicative -> unary .)
    Plus            reduce using rule 67 (multiplicative -> unary .)
    Minus           reduce using rule 67 (multiplicative -> unary .)
    Less            reduce using rule 67 (multiplicative -> unary .)
    Greater         reduce using rule 67 (multiplicative -> unary .)
    LessEqual       reduce using rule 67 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 67 (multiplicative -> unary .)
    NotEqual        reduce using rule 67 (multiplicative -> unary .)
    Equal           reduce using rule 67 (multiplicative -> unary .)
    BitAnd          reduce using rule 67 (multiplicative -> unary .)
    Xor             reduce using rule 67 (multiplicative -> unary .)
    BitOr           reduce using rule 67 (multiplicative -> unary .)
    And             reduce using rule 67 (multiplicative -> unary .)
    Question        reduce using rule 67 (multiplicative -> unary .)
    Or              reduce using rule 67 (multiplicative -> unary .)
    Semi            reduce using rule 67 (multiplicative -> unary .)
    RParen          reduce using rule 67 (multiplicative -> unary .)
    Comma           reduce using rule 67 (multiplicative -> unary .)
    RBrace          reduce using rule 67 (multiplicative -> unary .)
    RBracket        reduce using rule 67 (multiplicative -> unary .)
    Colon           reduce using rule 67 (multiplicative -> unary .)


state 33

    (68) unary -> postfix .

    Mul             reduce using rule 68 (unary -> postfix .)
    Div             reduce using rule 68 (unary -> postfix .)
    Mod             reduce using rule 68 (unary -> postfix .)
    Plus            reduce using rule 68 (unary -> postfix .)
    Minus           reduce using rule 68 (unary -> postfix .)
    Less            reduce using rule 68 (unary -> postfix .)
    Greater         reduce using rule 68 (unary -> postfix .)
    LessEqual       reduce using rule 68 (unary -> postfix .)
    GreaterEqual    reduce using rule 68 (unary -> postfix .)
    NotEqual        reduce using rule 68 (unary -> postfix .)
    Equal           reduce using rule 68 (unary -> postfix .)
    BitAnd          reduce using rule 68 (unary -> postfix .)
    Xor             reduce using rule 68 (unary -> postfix .)
    BitOr           reduce using rule 68 (unary -> postfix .)
    And             reduce using rule 68 (unary -> postfix .)
    Question        reduce using rule 68 (unary -> postfix .)
    Or              reduce using rule 68 (unary -> postfix .)
    Semi            reduce using rule 68 (unary -> postfix .)
    RParen          reduce using rule 68 (unary -> postfix .)
    Comma           reduce using rule 68 (unary -> postfix .)
    RBrace          reduce using rule 68 (unary -> postfix .)
    RBracket        reduce using rule 68 (unary -> postfix .)
    Colon           reduce using rule 68 (unary -> postfix .)


state 34

    (72) unary -> BitNot . unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    unary                          shift and go to state 71
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 35

    (73) unary -> Not . unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    unary                          shift and go to state 72
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 36

    (69) postfix -> primary .

    Mul             reduce using rule 69 (postfix -> primary .)
    Div             reduce using rule 69 (postfix -> primary .)
    Mod             reduce using rule 69 (postfix -> primary .)
    Plus            reduce using rule 69 (postfix -> primary .)
    Minus           reduce using rule 69 (postfix -> primary .)
    Less            reduce using rule 69 (postfix -> primary .)
    Greater         reduce using rule 69 (postfix -> primary .)
    LessEqual       reduce using rule 69 (postfix -> primary .)
    GreaterEqual    reduce using rule 69 (postfix -> primary .)
    NotEqual        reduce using rule 69 (postfix -> primary .)
    Equal           reduce using rule 69 (postfix -> primary .)
    BitAnd          reduce using rule 69 (postfix -> primary .)
    Xor             reduce using rule 69 (postfix -> primary .)
    BitOr           reduce using rule 69 (postfix -> primary .)
    And             reduce using rule 69 (postfix -> primary .)
    Question        reduce using rule 69 (postfix -> primary .)
    Or              reduce using rule 69 (postfix -> primary .)
    Semi            reduce using rule 69 (postfix -> primary .)
    RParen          reduce using rule 69 (postfix -> primary .)
    Comma           reduce using rule 69 (postfix -> primary .)
    RBrace          reduce using rule 69 (postfix -> primary .)
    RBracket        reduce using rule 69 (postfix -> primary .)
    Colon           reduce using rule 69 (postfix -> primary .)


state 37

    (97) primary -> LParen . expression RParen
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 73
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 38

    (95) primary -> Integer .

    Mul             reduce using rule 95 (primary -> Integer .)
    Div             reduce using rule 95 (primary -> Integer .)
    Mod             reduce using rule 95 (primary -> Integer .)
    Plus            reduce using rule 95 (primary -> Integer .)
    Minus           reduce using rule 95 (primary -> Integer .)
    Less            reduce using rule 95 (primary -> Integer .)
    Greater         reduce using rule 95 (primary -> Integer .)
    LessEqual       reduce using rule 95 (primary -> Integer .)
    GreaterEqual    reduce using rule 95 (primary -> Integer .)
    NotEqual        reduce using rule 95 (primary -> Integer .)
    Equal           reduce using rule 95 (primary -> Integer .)
    BitAnd          reduce using rule 95 (primary -> Integer .)
    Xor             reduce using rule 95 (primary -> Integer .)
    BitOr           reduce using rule 95 (primary -> Integer .)
    And             reduce using rule 95 (primary -> Integer .)
    Question        reduce using rule 95 (primary -> Integer .)
    Or              reduce using rule 95 (primary -> Integer .)
    Semi            reduce using rule 95 (primary -> Integer .)
    RParen          reduce using rule 95 (primary -> Integer .)
    Comma           reduce using rule 95 (primary -> Integer .)
    RBrace          reduce using rule 95 (primary -> Integer .)
    RBracket        reduce using rule 95 (primary -> Integer .)
    Colon           reduce using rule 95 (primary -> Integer .)


state 39

    (12) parameter -> type . Identifier
    (13) parameter -> type . Identifier LBracket maybe_int RBracket

    Identifier      shift and go to state 74


state 40

    (7) function -> type Identifier LParen parameter_list . RParen LBrace block RBrace
    (8) function -> type Identifier LParen parameter_list . RParen Semi

    RParen          shift and go to state 75


state 41

    (9) parameter_list -> parameter . Comma parameter_list
    (10) parameter_list -> parameter .

    Comma           shift and go to state 76
    RParen          reduce using rule 10 (parameter_list -> parameter .)


state 42

    (11) parameter_list -> empty .

    RParen          reduce using rule 11 (parameter_list -> empty .)


state 43

    (50) array -> LBracket Integer . RBracket array_sub

    RBracket        shift and go to state 77


state 44

    (44) declaration -> type Identifier array Assign array_expression .

    Semi            reduce using rule 44 (declaration -> type Identifier array Assign array_expression .)


state 45

    (45) array_expression -> LBrace . array_expression_sub RBrace
    (46) array_expression_sub -> . expression Comma array_expression_sub
    (47) array_expression_sub -> . expression
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    array_expression_sub           shift and go to state 78
    expression                     shift and go to state 79
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 46

    (74) refer -> Identifier refer_arguments .

    Assign          reduce using rule 74 (refer -> Identifier refer_arguments .)
    Mul             reduce using rule 74 (refer -> Identifier refer_arguments .)
    Div             reduce using rule 74 (refer -> Identifier refer_arguments .)
    Mod             reduce using rule 74 (refer -> Identifier refer_arguments .)
    Plus            reduce using rule 74 (refer -> Identifier refer_arguments .)
    Minus           reduce using rule 74 (refer -> Identifier refer_arguments .)
    Less            reduce using rule 74 (refer -> Identifier refer_arguments .)
    Greater         reduce using rule 74 (refer -> Identifier refer_arguments .)
    LessEqual       reduce using rule 74 (refer -> Identifier refer_arguments .)
    GreaterEqual    reduce using rule 74 (refer -> Identifier refer_arguments .)
    NotEqual        reduce using rule 74 (refer -> Identifier refer_arguments .)
    Equal           reduce using rule 74 (refer -> Identifier refer_arguments .)
    BitAnd          reduce using rule 74 (refer -> Identifier refer_arguments .)
    Xor             reduce using rule 74 (refer -> Identifier refer_arguments .)
    BitOr           reduce using rule 74 (refer -> Identifier refer_arguments .)
    And             reduce using rule 74 (refer -> Identifier refer_arguments .)
    Question        reduce using rule 74 (refer -> Identifier refer_arguments .)
    Or              reduce using rule 74 (refer -> Identifier refer_arguments .)
    Semi            reduce using rule 74 (refer -> Identifier refer_arguments .)
    RParen          reduce using rule 74 (refer -> Identifier refer_arguments .)
    Comma           reduce using rule 74 (refer -> Identifier refer_arguments .)
    RBrace          reduce using rule 74 (refer -> Identifier refer_arguments .)
    RBracket        reduce using rule 74 (refer -> Identifier refer_arguments .)
    Colon           reduce using rule 74 (refer -> Identifier refer_arguments .)


state 47

    (70) postfix -> Identifier LParen . expression_list RParen
    (53) expression_list -> . expression Comma expression_list
    (54) expression_list -> . expression
    (55) expression_list -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression_list                shift and go to state 80
    expression                     shift and go to state 81
    empty                          shift and go to state 82
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 48

    (75) refer_arguments -> LBracket . expression RBracket refer_arguments
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 83
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 49

    (76) refer_arguments -> empty .

    Assign          reduce using rule 76 (refer_arguments -> empty .)
    Mul             reduce using rule 76 (refer_arguments -> empty .)
    Div             reduce using rule 76 (refer_arguments -> empty .)
    Mod             reduce using rule 76 (refer_arguments -> empty .)
    Plus            reduce using rule 76 (refer_arguments -> empty .)
    Minus           reduce using rule 76 (refer_arguments -> empty .)
    Less            reduce using rule 76 (refer_arguments -> empty .)
    Greater         reduce using rule 76 (refer_arguments -> empty .)
    LessEqual       reduce using rule 76 (refer_arguments -> empty .)
    GreaterEqual    reduce using rule 76 (refer_arguments -> empty .)
    NotEqual        reduce using rule 76 (refer_arguments -> empty .)
    Equal           reduce using rule 76 (refer_arguments -> empty .)
    BitAnd          reduce using rule 76 (refer_arguments -> empty .)
    Xor             reduce using rule 76 (refer_arguments -> empty .)
    BitOr           reduce using rule 76 (refer_arguments -> empty .)
    And             reduce using rule 76 (refer_arguments -> empty .)
    Question        reduce using rule 76 (refer_arguments -> empty .)
    Or              reduce using rule 76 (refer_arguments -> empty .)
    Semi            reduce using rule 76 (refer_arguments -> empty .)
    RParen          reduce using rule 76 (refer_arguments -> empty .)
    Comma           reduce using rule 76 (refer_arguments -> empty .)
    RBrace          reduce using rule 76 (refer_arguments -> empty .)
    RBracket        reduce using rule 76 (refer_arguments -> empty .)
    Colon           reduce using rule 76 (refer_arguments -> empty .)


state 50

    (77) assignment -> refer Assign . expression
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    refer                          shift and go to state 21
    expression                     shift and go to state 84
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 51

    (94) conditional -> logical_or Question . expression Colon conditional
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    logical_or                     shift and go to state 22
    expression                     shift and go to state 85
    conditional                    shift and go to state 20
    assignment                     shift and go to state 19
    refer                          shift and go to state 21
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 52

    (78) logical_or -> logical_or Or . logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    logical_and                    shift and go to state 86
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 53

    (79) logical_and -> logical_and And . bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    bit_or                         shift and go to state 87
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 54

    (80) bit_or -> bit_or BitOr . xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    xor                            shift and go to state 88
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 55

    (81) xor -> xor Xor . bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    bit_and                        shift and go to state 89
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 56

    (82) bit_and -> bit_and BitAnd . equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    equality                       shift and go to state 90
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 57

    (83) equality -> equality NotEqual . relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    relational                     shift and go to state 91
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 58

    (84) equality -> equality Equal . relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    relational                     shift and go to state 92
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 59

    (85) relational -> relational Less . additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    additive                       shift and go to state 93
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 60

    (86) relational -> relational Greater . additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    additive                       shift and go to state 94
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 61

    (87) relational -> relational LessEqual . additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    additive                       shift and go to state 95
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 62

    (88) relational -> relational GreaterEqual . additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    additive                       shift and go to state 96
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 63

    (89) additive -> additive Plus . multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    multiplicative                 shift and go to state 97
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 64

    (90) additive -> additive Minus . multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    multiplicative                 shift and go to state 98
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 65

    (91) multiplicative -> multiplicative Mul . unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    unary                          shift and go to state 99
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 66

    (92) multiplicative -> multiplicative Div . unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    unary                          shift and go to state 100
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 67

    (93) multiplicative -> multiplicative Mod . unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    unary                          shift and go to state 101
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 68

    (71) unary -> Minus unary .

    Mul             reduce using rule 71 (unary -> Minus unary .)
    Div             reduce using rule 71 (unary -> Minus unary .)
    Mod             reduce using rule 71 (unary -> Minus unary .)
    Plus            reduce using rule 71 (unary -> Minus unary .)
    Minus           reduce using rule 71 (unary -> Minus unary .)
    Less            reduce using rule 71 (unary -> Minus unary .)
    Greater         reduce using rule 71 (unary -> Minus unary .)
    LessEqual       reduce using rule 71 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 71 (unary -> Minus unary .)
    NotEqual        reduce using rule 71 (unary -> Minus unary .)
    Equal           reduce using rule 71 (unary -> Minus unary .)
    BitAnd          reduce using rule 71 (unary -> Minus unary .)
    Xor             reduce using rule 71 (unary -> Minus unary .)
    BitOr           reduce using rule 71 (unary -> Minus unary .)
    And             reduce using rule 71 (unary -> Minus unary .)
    Question        reduce using rule 71 (unary -> Minus unary .)
    Or              reduce using rule 71 (unary -> Minus unary .)
    Semi            reduce using rule 71 (unary -> Minus unary .)
    RParen          reduce using rule 71 (unary -> Minus unary .)
    Comma           reduce using rule 71 (unary -> Minus unary .)
    RBrace          reduce using rule 71 (unary -> Minus unary .)
    RBracket        reduce using rule 71 (unary -> Minus unary .)
    Colon           reduce using rule 71 (unary -> Minus unary .)


state 69

    (70) postfix -> Identifier . LParen expression_list RParen
    (74) refer -> Identifier . refer_arguments
    (75) refer_arguments -> . LBracket expression RBracket refer_arguments
    (76) refer_arguments -> . empty
    (1) empty -> .

    LParen          shift and go to state 47
    LBracket        shift and go to state 48
    Mul             reduce using rule 1 (empty -> .)
    Div             reduce using rule 1 (empty -> .)
    Mod             reduce using rule 1 (empty -> .)
    Plus            reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    Less            reduce using rule 1 (empty -> .)
    Greater         reduce using rule 1 (empty -> .)
    LessEqual       reduce using rule 1 (empty -> .)
    GreaterEqual    reduce using rule 1 (empty -> .)
    NotEqual        reduce using rule 1 (empty -> .)
    Equal           reduce using rule 1 (empty -> .)
    BitAnd          reduce using rule 1 (empty -> .)
    Xor             reduce using rule 1 (empty -> .)
    BitOr           reduce using rule 1 (empty -> .)
    And             reduce using rule 1 (empty -> .)
    Question        reduce using rule 1 (empty -> .)
    Or              reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    RBrace          reduce using rule 1 (empty -> .)
    RBracket        reduce using rule 1 (empty -> .)
    Colon           reduce using rule 1 (empty -> .)

    refer_arguments                shift and go to state 46
    empty                          shift and go to state 49

state 70

    (96) primary -> refer .

    Mul             reduce using rule 96 (primary -> refer .)
    Div             reduce using rule 96 (primary -> refer .)
    Mod             reduce using rule 96 (primary -> refer .)
    Plus            reduce using rule 96 (primary -> refer .)
    Minus           reduce using rule 96 (primary -> refer .)
    Less            reduce using rule 96 (primary -> refer .)
    Greater         reduce using rule 96 (primary -> refer .)
    LessEqual       reduce using rule 96 (primary -> refer .)
    GreaterEqual    reduce using rule 96 (primary -> refer .)
    NotEqual        reduce using rule 96 (primary -> refer .)
    Equal           reduce using rule 96 (primary -> refer .)
    BitAnd          reduce using rule 96 (primary -> refer .)
    Xor             reduce using rule 96 (primary -> refer .)
    BitOr           reduce using rule 96 (primary -> refer .)
    And             reduce using rule 96 (primary -> refer .)
    Question        reduce using rule 96 (primary -> refer .)
    Or              reduce using rule 96 (primary -> refer .)
    Semi            reduce using rule 96 (primary -> refer .)
    RParen          reduce using rule 96 (primary -> refer .)
    Comma           reduce using rule 96 (primary -> refer .)
    RBrace          reduce using rule 96 (primary -> refer .)
    RBracket        reduce using rule 96 (primary -> refer .)
    Colon           reduce using rule 96 (primary -> refer .)


state 71

    (72) unary -> BitNot unary .

    Mul             reduce using rule 72 (unary -> BitNot unary .)
    Div             reduce using rule 72 (unary -> BitNot unary .)
    Mod             reduce using rule 72 (unary -> BitNot unary .)
    Plus            reduce using rule 72 (unary -> BitNot unary .)
    Minus           reduce using rule 72 (unary -> BitNot unary .)
    Less            reduce using rule 72 (unary -> BitNot unary .)
    Greater         reduce using rule 72 (unary -> BitNot unary .)
    LessEqual       reduce using rule 72 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 72 (unary -> BitNot unary .)
    NotEqual        reduce using rule 72 (unary -> BitNot unary .)
    Equal           reduce using rule 72 (unary -> BitNot unary .)
    BitAnd          reduce using rule 72 (unary -> BitNot unary .)
    Xor             reduce using rule 72 (unary -> BitNot unary .)
    BitOr           reduce using rule 72 (unary -> BitNot unary .)
    And             reduce using rule 72 (unary -> BitNot unary .)
    Question        reduce using rule 72 (unary -> BitNot unary .)
    Or              reduce using rule 72 (unary -> BitNot unary .)
    Semi            reduce using rule 72 (unary -> BitNot unary .)
    RParen          reduce using rule 72 (unary -> BitNot unary .)
    Comma           reduce using rule 72 (unary -> BitNot unary .)
    RBrace          reduce using rule 72 (unary -> BitNot unary .)
    RBracket        reduce using rule 72 (unary -> BitNot unary .)
    Colon           reduce using rule 72 (unary -> BitNot unary .)


state 72

    (73) unary -> Not unary .

    Mul             reduce using rule 73 (unary -> Not unary .)
    Div             reduce using rule 73 (unary -> Not unary .)
    Mod             reduce using rule 73 (unary -> Not unary .)
    Plus            reduce using rule 73 (unary -> Not unary .)
    Minus           reduce using rule 73 (unary -> Not unary .)
    Less            reduce using rule 73 (unary -> Not unary .)
    Greater         reduce using rule 73 (unary -> Not unary .)
    LessEqual       reduce using rule 73 (unary -> Not unary .)
    GreaterEqual    reduce using rule 73 (unary -> Not unary .)
    NotEqual        reduce using rule 73 (unary -> Not unary .)
    Equal           reduce using rule 73 (unary -> Not unary .)
    BitAnd          reduce using rule 73 (unary -> Not unary .)
    Xor             reduce using rule 73 (unary -> Not unary .)
    BitOr           reduce using rule 73 (unary -> Not unary .)
    And             reduce using rule 73 (unary -> Not unary .)
    Question        reduce using rule 73 (unary -> Not unary .)
    Or              reduce using rule 73 (unary -> Not unary .)
    Semi            reduce using rule 73 (unary -> Not unary .)
    RParen          reduce using rule 73 (unary -> Not unary .)
    Comma           reduce using rule 73 (unary -> Not unary .)
    RBrace          reduce using rule 73 (unary -> Not unary .)
    RBracket        reduce using rule 73 (unary -> Not unary .)
    Colon           reduce using rule 73 (unary -> Not unary .)


state 73

    (97) primary -> LParen expression . RParen

    RParen          shift and go to state 102


state 74

    (12) parameter -> type Identifier .
    (13) parameter -> type Identifier . LBracket maybe_int RBracket

    Comma           reduce using rule 12 (parameter -> type Identifier .)
    RParen          reduce using rule 12 (parameter -> type Identifier .)
    LBracket        shift and go to state 103


state 75

    (7) function -> type Identifier LParen parameter_list RParen . LBrace block RBrace
    (8) function -> type Identifier LParen parameter_list RParen . Semi

    LBrace          shift and go to state 104
    Semi            shift and go to state 105


state 76

    (9) parameter_list -> parameter Comma . parameter_list
    (9) parameter_list -> . parameter Comma parameter_list
    (10) parameter_list -> . parameter
    (11) parameter_list -> . empty
    (12) parameter -> . type Identifier
    (13) parameter -> . type Identifier LBracket maybe_int RBracket
    (1) empty -> .
    (2) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    parameter                      shift and go to state 41
    parameter_list                 shift and go to state 106
    empty                          shift and go to state 42
    type                           shift and go to state 39

state 77

    (50) array -> LBracket Integer RBracket . array_sub
    (48) array_sub -> . empty
    (49) array_sub -> . LBracket Integer RBracket array_sub
    (1) empty -> .

    LBracket        shift and go to state 107
    Assign          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    array_sub                      shift and go to state 108
    empty                          shift and go to state 109

state 78

    (45) array_expression -> LBrace array_expression_sub . RBrace

    RBrace          shift and go to state 110


state 79

    (46) array_expression_sub -> expression . Comma array_expression_sub
    (47) array_expression_sub -> expression .

    Comma           shift and go to state 111
    RBrace          reduce using rule 47 (array_expression_sub -> expression .)


state 80

    (70) postfix -> Identifier LParen expression_list . RParen

    RParen          shift and go to state 112


state 81

    (53) expression_list -> expression . Comma expression_list
    (54) expression_list -> expression .

    Comma           shift and go to state 113
    RParen          reduce using rule 54 (expression_list -> expression .)


state 82

    (55) expression_list -> empty .

    RParen          reduce using rule 55 (expression_list -> empty .)


state 83

    (75) refer_arguments -> LBracket expression . RBracket refer_arguments

    RBracket        shift and go to state 114


state 84

    (77) assignment -> refer Assign expression .

    Semi            reduce using rule 77 (assignment -> refer Assign expression .)
    RParen          reduce using rule 77 (assignment -> refer Assign expression .)
    Comma           reduce using rule 77 (assignment -> refer Assign expression .)
    RBrace          reduce using rule 77 (assignment -> refer Assign expression .)
    RBracket        reduce using rule 77 (assignment -> refer Assign expression .)
    Colon           reduce using rule 77 (assignment -> refer Assign expression .)


state 85

    (94) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 115


state 86

    (78) logical_or -> logical_or Or logical_and .
    (79) logical_and -> logical_and . And bit_or

    Question        reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    RBrace          reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    RBracket        reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 78 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 53


state 87

    (79) logical_and -> logical_and And bit_or .
    (80) bit_or -> bit_or . BitOr xor

    And             reduce using rule 79 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 79 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 79 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 79 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 79 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 79 (logical_and -> logical_and And bit_or .)
    RBrace          reduce using rule 79 (logical_and -> logical_and And bit_or .)
    RBracket        reduce using rule 79 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 79 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 54


state 88

    (80) bit_or -> bit_or BitOr xor .
    (81) xor -> xor . Xor bit_and

    BitOr           reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    RBrace          reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    RBracket        reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 80 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 55


state 89

    (81) xor -> xor Xor bit_and .
    (82) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 81 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 81 (xor -> xor Xor bit_and .)
    And             reduce using rule 81 (xor -> xor Xor bit_and .)
    Question        reduce using rule 81 (xor -> xor Xor bit_and .)
    Or              reduce using rule 81 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 81 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 81 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 81 (xor -> xor Xor bit_and .)
    RBrace          reduce using rule 81 (xor -> xor Xor bit_and .)
    RBracket        reduce using rule 81 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 81 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 56


state 90

    (82) bit_and -> bit_and BitAnd equality .
    (83) equality -> equality . NotEqual relational
    (84) equality -> equality . Equal relational

    BitAnd          reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    RBrace          reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    RBracket        reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 82 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 57
    Equal           shift and go to state 58


state 91

    (83) equality -> equality NotEqual relational .
    (85) relational -> relational . Less additive
    (86) relational -> relational . Greater additive
    (87) relational -> relational . LessEqual additive
    (88) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 83 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 83 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 83 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 83 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 83 (equality -> equality NotEqual relational .)
    And             reduce using rule 83 (equality -> equality NotEqual relational .)
    Question        reduce using rule 83 (equality -> equality NotEqual relational .)
    Or              reduce using rule 83 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 83 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 83 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 83 (equality -> equality NotEqual relational .)
    RBrace          reduce using rule 83 (equality -> equality NotEqual relational .)
    RBracket        reduce using rule 83 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 83 (equality -> equality NotEqual relational .)
    Less            shift and go to state 59
    Greater         shift and go to state 60
    LessEqual       shift and go to state 61
    GreaterEqual    shift and go to state 62


state 92

    (84) equality -> equality Equal relational .
    (85) relational -> relational . Less additive
    (86) relational -> relational . Greater additive
    (87) relational -> relational . LessEqual additive
    (88) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 84 (equality -> equality Equal relational .)
    Equal           reduce using rule 84 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 84 (equality -> equality Equal relational .)
    Xor             reduce using rule 84 (equality -> equality Equal relational .)
    BitOr           reduce using rule 84 (equality -> equality Equal relational .)
    And             reduce using rule 84 (equality -> equality Equal relational .)
    Question        reduce using rule 84 (equality -> equality Equal relational .)
    Or              reduce using rule 84 (equality -> equality Equal relational .)
    Semi            reduce using rule 84 (equality -> equality Equal relational .)
    RParen          reduce using rule 84 (equality -> equality Equal relational .)
    Comma           reduce using rule 84 (equality -> equality Equal relational .)
    RBrace          reduce using rule 84 (equality -> equality Equal relational .)
    RBracket        reduce using rule 84 (equality -> equality Equal relational .)
    Colon           reduce using rule 84 (equality -> equality Equal relational .)
    Less            shift and go to state 59
    Greater         shift and go to state 60
    LessEqual       shift and go to state 61
    GreaterEqual    shift and go to state 62


state 93

    (85) relational -> relational Less additive .
    (89) additive -> additive . Plus multiplicative
    (90) additive -> additive . Minus multiplicative

    Less            reduce using rule 85 (relational -> relational Less additive .)
    Greater         reduce using rule 85 (relational -> relational Less additive .)
    LessEqual       reduce using rule 85 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 85 (relational -> relational Less additive .)
    NotEqual        reduce using rule 85 (relational -> relational Less additive .)
    Equal           reduce using rule 85 (relational -> relational Less additive .)
    BitAnd          reduce using rule 85 (relational -> relational Less additive .)
    Xor             reduce using rule 85 (relational -> relational Less additive .)
    BitOr           reduce using rule 85 (relational -> relational Less additive .)
    And             reduce using rule 85 (relational -> relational Less additive .)
    Question        reduce using rule 85 (relational -> relational Less additive .)
    Or              reduce using rule 85 (relational -> relational Less additive .)
    Semi            reduce using rule 85 (relational -> relational Less additive .)
    RParen          reduce using rule 85 (relational -> relational Less additive .)
    Comma           reduce using rule 85 (relational -> relational Less additive .)
    RBrace          reduce using rule 85 (relational -> relational Less additive .)
    RBracket        reduce using rule 85 (relational -> relational Less additive .)
    Colon           reduce using rule 85 (relational -> relational Less additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 94

    (86) relational -> relational Greater additive .
    (89) additive -> additive . Plus multiplicative
    (90) additive -> additive . Minus multiplicative

    Less            reduce using rule 86 (relational -> relational Greater additive .)
    Greater         reduce using rule 86 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 86 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 86 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 86 (relational -> relational Greater additive .)
    Equal           reduce using rule 86 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 86 (relational -> relational Greater additive .)
    Xor             reduce using rule 86 (relational -> relational Greater additive .)
    BitOr           reduce using rule 86 (relational -> relational Greater additive .)
    And             reduce using rule 86 (relational -> relational Greater additive .)
    Question        reduce using rule 86 (relational -> relational Greater additive .)
    Or              reduce using rule 86 (relational -> relational Greater additive .)
    Semi            reduce using rule 86 (relational -> relational Greater additive .)
    RParen          reduce using rule 86 (relational -> relational Greater additive .)
    Comma           reduce using rule 86 (relational -> relational Greater additive .)
    RBrace          reduce using rule 86 (relational -> relational Greater additive .)
    RBracket        reduce using rule 86 (relational -> relational Greater additive .)
    Colon           reduce using rule 86 (relational -> relational Greater additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 95

    (87) relational -> relational LessEqual additive .
    (89) additive -> additive . Plus multiplicative
    (90) additive -> additive . Minus multiplicative

    Less            reduce using rule 87 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 87 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 87 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 87 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 87 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 87 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 87 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 87 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 87 (relational -> relational LessEqual additive .)
    And             reduce using rule 87 (relational -> relational LessEqual additive .)
    Question        reduce using rule 87 (relational -> relational LessEqual additive .)
    Or              reduce using rule 87 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 87 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 87 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 87 (relational -> relational LessEqual additive .)
    RBrace          reduce using rule 87 (relational -> relational LessEqual additive .)
    RBracket        reduce using rule 87 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 87 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 96

    (88) relational -> relational GreaterEqual additive .
    (89) additive -> additive . Plus multiplicative
    (90) additive -> additive . Minus multiplicative

    Less            reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 88 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 88 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 88 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 88 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 88 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 88 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 88 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 88 (relational -> relational GreaterEqual additive .)
    RBrace          reduce using rule 88 (relational -> relational GreaterEqual additive .)
    RBracket        reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 88 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 97

    (89) additive -> additive Plus multiplicative .
    (91) multiplicative -> multiplicative . Mul unary
    (92) multiplicative -> multiplicative . Div unary
    (93) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 89 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 89 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 89 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 89 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 89 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 89 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 89 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 89 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 89 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 89 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 89 (additive -> additive Plus multiplicative .)
    And             reduce using rule 89 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 89 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 89 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 89 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 89 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 89 (additive -> additive Plus multiplicative .)
    RBrace          reduce using rule 89 (additive -> additive Plus multiplicative .)
    RBracket        reduce using rule 89 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 89 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 65
    Div             shift and go to state 66
    Mod             shift and go to state 67


state 98

    (90) additive -> additive Minus multiplicative .
    (91) multiplicative -> multiplicative . Mul unary
    (92) multiplicative -> multiplicative . Div unary
    (93) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 90 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 90 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 90 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 90 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 90 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 90 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 90 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 90 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 90 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 90 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 90 (additive -> additive Minus multiplicative .)
    And             reduce using rule 90 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 90 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 90 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 90 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 90 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 90 (additive -> additive Minus multiplicative .)
    RBrace          reduce using rule 90 (additive -> additive Minus multiplicative .)
    RBracket        reduce using rule 90 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 90 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 65
    Div             shift and go to state 66
    Mod             shift and go to state 67


state 99

    (91) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    RBrace          reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    RBracket        reduce using rule 91 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 91 (multiplicative -> multiplicative Mul unary .)


state 100

    (92) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    RBrace          reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    RBracket        reduce using rule 92 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 92 (multiplicative -> multiplicative Div unary .)


state 101

    (93) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    RBrace          reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    RBracket        reduce using rule 93 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 93 (multiplicative -> multiplicative Mod unary .)


state 102

    (97) primary -> LParen expression RParen .

    Mul             reduce using rule 97 (primary -> LParen expression RParen .)
    Div             reduce using rule 97 (primary -> LParen expression RParen .)
    Mod             reduce using rule 97 (primary -> LParen expression RParen .)
    Plus            reduce using rule 97 (primary -> LParen expression RParen .)
    Minus           reduce using rule 97 (primary -> LParen expression RParen .)
    Less            reduce using rule 97 (primary -> LParen expression RParen .)
    Greater         reduce using rule 97 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 97 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 97 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 97 (primary -> LParen expression RParen .)
    Equal           reduce using rule 97 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 97 (primary -> LParen expression RParen .)
    Xor             reduce using rule 97 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 97 (primary -> LParen expression RParen .)
    And             reduce using rule 97 (primary -> LParen expression RParen .)
    Question        reduce using rule 97 (primary -> LParen expression RParen .)
    Or              reduce using rule 97 (primary -> LParen expression RParen .)
    Semi            reduce using rule 97 (primary -> LParen expression RParen .)
    RParen          reduce using rule 97 (primary -> LParen expression RParen .)
    Comma           reduce using rule 97 (primary -> LParen expression RParen .)
    RBrace          reduce using rule 97 (primary -> LParen expression RParen .)
    RBracket        reduce using rule 97 (primary -> LParen expression RParen .)
    Colon           reduce using rule 97 (primary -> LParen expression RParen .)


state 103

    (13) parameter -> type Identifier LBracket . maybe_int RBracket
    (14) maybe_int -> . Integer
    (15) maybe_int -> . empty
    (1) empty -> .

    Integer         shift and go to state 117
    RBracket        reduce using rule 1 (empty -> .)

    maybe_int                      shift and go to state 116
    empty                          shift and go to state 118

state 104

    (7) function -> type Identifier LParen parameter_list RParen LBrace . block RBrace
    (16) block -> . block block_item
    (17) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 119
    empty                          shift and go to state 120

state 105

    (8) function -> type Identifier LParen parameter_list RParen Semi .

    Int             reduce using rule 8 (function -> type Identifier LParen parameter_list RParen Semi .)
    $end            reduce using rule 8 (function -> type Identifier LParen parameter_list RParen Semi .)


state 106

    (9) parameter_list -> parameter Comma parameter_list .

    RParen          reduce using rule 9 (parameter_list -> parameter Comma parameter_list .)


state 107

    (49) array_sub -> LBracket . Integer RBracket array_sub

    Integer         shift and go to state 121


state 108

    (50) array -> LBracket Integer RBracket array_sub .

    Assign          reduce using rule 50 (array -> LBracket Integer RBracket array_sub .)
    Semi            reduce using rule 50 (array -> LBracket Integer RBracket array_sub .)


state 109

    (48) array_sub -> empty .

    Assign          reduce using rule 48 (array_sub -> empty .)
    Semi            reduce using rule 48 (array_sub -> empty .)


state 110

    (45) array_expression -> LBrace array_expression_sub RBrace .

    Semi            reduce using rule 45 (array_expression -> LBrace array_expression_sub RBrace .)


state 111

    (46) array_expression_sub -> expression Comma . array_expression_sub
    (46) array_expression_sub -> . expression Comma array_expression_sub
    (47) array_expression_sub -> . expression
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 79
    array_expression_sub           shift and go to state 122
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 112

    (70) postfix -> Identifier LParen expression_list RParen .

    Mul             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    RBrace          reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    RBracket        reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)


state 113

    (53) expression_list -> expression Comma . expression_list
    (53) expression_list -> . expression Comma expression_list
    (54) expression_list -> . expression
    (55) expression_list -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 81
    expression_list                shift and go to state 123
    empty                          shift and go to state 82
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 114

    (75) refer_arguments -> LBracket expression RBracket . refer_arguments
    (75) refer_arguments -> . LBracket expression RBracket refer_arguments
    (76) refer_arguments -> . empty
    (1) empty -> .

    LBracket        shift and go to state 48
    Assign          reduce using rule 1 (empty -> .)
    Mul             reduce using rule 1 (empty -> .)
    Div             reduce using rule 1 (empty -> .)
    Mod             reduce using rule 1 (empty -> .)
    Plus            reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    Less            reduce using rule 1 (empty -> .)
    Greater         reduce using rule 1 (empty -> .)
    LessEqual       reduce using rule 1 (empty -> .)
    GreaterEqual    reduce using rule 1 (empty -> .)
    NotEqual        reduce using rule 1 (empty -> .)
    Equal           reduce using rule 1 (empty -> .)
    BitAnd          reduce using rule 1 (empty -> .)
    Xor             reduce using rule 1 (empty -> .)
    BitOr           reduce using rule 1 (empty -> .)
    And             reduce using rule 1 (empty -> .)
    Question        reduce using rule 1 (empty -> .)
    Or              reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    RBrace          reduce using rule 1 (empty -> .)
    RBracket        reduce using rule 1 (empty -> .)
    Colon           reduce using rule 1 (empty -> .)

    refer_arguments                shift and go to state 124
    empty                          shift and go to state 49

state 115

    (94) conditional -> logical_or Question expression Colon . conditional
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen
    (74) refer -> . Identifier refer_arguments

    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Identifier      shift and go to state 69
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    logical_or                     shift and go to state 22
    conditional                    shift and go to state 125
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36
    refer                          shift and go to state 70

state 116

    (13) parameter -> type Identifier LBracket maybe_int . RBracket

    RBracket        shift and go to state 126


state 117

    (14) maybe_int -> Integer .

    RBracket        reduce using rule 14 (maybe_int -> Integer .)


state 118

    (15) maybe_int -> empty .

    RBracket        reduce using rule 15 (maybe_int -> empty .)


state 119

    (7) function -> type Identifier LParen parameter_list RParen LBrace block . RBrace
    (16) block -> block . block_item
    (18) block_item -> . statement
    (19) block_item -> . declaration Semi
    (20) statement -> . statement_matched
    (21) statement -> . statement_unmatched
    (43) declaration -> . type Identifier array
    (44) declaration -> . type Identifier array Assign array_expression
    (51) declaration -> . type Identifier
    (52) declaration -> . type Identifier Assign expression
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (2) type -> . Int
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    RBrace          shift and go to state 129
    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    type                           shift and go to state 127
    block_item                     shift and go to state 130
    statement                      shift and go to state 131
    declaration                    shift and go to state 132
    statement_matched              shift and go to state 133
    statement_unmatched            shift and go to state 134
    expression                     shift and go to state 135
    opt_expression                 shift and go to state 139
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 120

    (17) block -> empty .

    RBrace          reduce using rule 17 (block -> empty .)
    If              reduce using rule 17 (block -> empty .)
    While           reduce using rule 17 (block -> empty .)
    For             reduce using rule 17 (block -> empty .)
    Do              reduce using rule 17 (block -> empty .)
    Continue        reduce using rule 17 (block -> empty .)
    Return          reduce using rule 17 (block -> empty .)
    LBrace          reduce using rule 17 (block -> empty .)
    Break           reduce using rule 17 (block -> empty .)
    Int             reduce using rule 17 (block -> empty .)
    Identifier      reduce using rule 17 (block -> empty .)
    Minus           reduce using rule 17 (block -> empty .)
    BitNot          reduce using rule 17 (block -> empty .)
    Not             reduce using rule 17 (block -> empty .)
    Integer         reduce using rule 17 (block -> empty .)
    LParen          reduce using rule 17 (block -> empty .)
    Semi            reduce using rule 17 (block -> empty .)


state 121

    (49) array_sub -> LBracket Integer . RBracket array_sub

    RBracket        shift and go to state 145


state 122

    (46) array_expression_sub -> expression Comma array_expression_sub .

    RBrace          reduce using rule 46 (array_expression_sub -> expression Comma array_expression_sub .)


state 123

    (53) expression_list -> expression Comma expression_list .

    RParen          reduce using rule 53 (expression_list -> expression Comma expression_list .)


state 124

    (75) refer_arguments -> LBracket expression RBracket refer_arguments .

    Assign          reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Mul             reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Div             reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Mod             reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Plus            reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Minus           reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Less            reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Greater         reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    LessEqual       reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    GreaterEqual    reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    NotEqual        reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Equal           reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    BitAnd          reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Xor             reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    BitOr           reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    And             reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Question        reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Or              reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Semi            reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    RParen          reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Comma           reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    RBrace          reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    RBracket        reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)
    Colon           reduce using rule 75 (refer_arguments -> LBracket expression RBracket refer_arguments .)


state 125

    (94) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 94 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 94 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 94 (conditional -> logical_or Question expression Colon conditional .)
    RBrace          reduce using rule 94 (conditional -> logical_or Question expression Colon conditional .)
    RBracket        reduce using rule 94 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 94 (conditional -> logical_or Question expression Colon conditional .)


state 126

    (13) parameter -> type Identifier LBracket maybe_int RBracket .

    Comma           reduce using rule 13 (parameter -> type Identifier LBracket maybe_int RBracket .)
    RParen          reduce using rule 13 (parameter -> type Identifier LBracket maybe_int RBracket .)


state 127

    (43) declaration -> type . Identifier array
    (44) declaration -> type . Identifier array Assign array_expression
    (51) declaration -> type . Identifier
    (52) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 146


state 128

    (39) statement_matched -> LBrace . block RBrace
    (16) block -> . block block_item
    (17) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 147
    empty                          shift and go to state 120

state 129

    (7) function -> type Identifier LParen parameter_list RParen LBrace block RBrace .

    Int             reduce using rule 7 (function -> type Identifier LParen parameter_list RParen LBrace block RBrace .)
    $end            reduce using rule 7 (function -> type Identifier LParen parameter_list RParen LBrace block RBrace .)


state 130

    (16) block -> block block_item .

    RBrace          reduce using rule 16 (block -> block block_item .)
    If              reduce using rule 16 (block -> block block_item .)
    While           reduce using rule 16 (block -> block block_item .)
    For             reduce using rule 16 (block -> block block_item .)
    Do              reduce using rule 16 (block -> block block_item .)
    Continue        reduce using rule 16 (block -> block block_item .)
    Return          reduce using rule 16 (block -> block block_item .)
    LBrace          reduce using rule 16 (block -> block block_item .)
    Break           reduce using rule 16 (block -> block block_item .)
    Int             reduce using rule 16 (block -> block block_item .)
    Identifier      reduce using rule 16 (block -> block block_item .)
    Minus           reduce using rule 16 (block -> block block_item .)
    BitNot          reduce using rule 16 (block -> block block_item .)
    Not             reduce using rule 16 (block -> block block_item .)
    Integer         reduce using rule 16 (block -> block block_item .)
    LParen          reduce using rule 16 (block -> block block_item .)
    Semi            reduce using rule 16 (block -> block block_item .)


state 131

    (18) block_item -> statement .

    RBrace          reduce using rule 18 (block_item -> statement .)
    If              reduce using rule 18 (block_item -> statement .)
    While           reduce using rule 18 (block_item -> statement .)
    For             reduce using rule 18 (block_item -> statement .)
    Do              reduce using rule 18 (block_item -> statement .)
    Continue        reduce using rule 18 (block_item -> statement .)
    Return          reduce using rule 18 (block_item -> statement .)
    LBrace          reduce using rule 18 (block_item -> statement .)
    Break           reduce using rule 18 (block_item -> statement .)
    Int             reduce using rule 18 (block_item -> statement .)
    Identifier      reduce using rule 18 (block_item -> statement .)
    Minus           reduce using rule 18 (block_item -> statement .)
    BitNot          reduce using rule 18 (block_item -> statement .)
    Not             reduce using rule 18 (block_item -> statement .)
    Integer         reduce using rule 18 (block_item -> statement .)
    LParen          reduce using rule 18 (block_item -> statement .)
    Semi            reduce using rule 18 (block_item -> statement .)


state 132

    (19) block_item -> declaration . Semi

    Semi            shift and go to state 148


state 133

    (20) statement -> statement_matched .

    RBrace          reduce using rule 20 (statement -> statement_matched .)
    If              reduce using rule 20 (statement -> statement_matched .)
    While           reduce using rule 20 (statement -> statement_matched .)
    For             reduce using rule 20 (statement -> statement_matched .)
    Do              reduce using rule 20 (statement -> statement_matched .)
    Continue        reduce using rule 20 (statement -> statement_matched .)
    Return          reduce using rule 20 (statement -> statement_matched .)
    LBrace          reduce using rule 20 (statement -> statement_matched .)
    Break           reduce using rule 20 (statement -> statement_matched .)
    Int             reduce using rule 20 (statement -> statement_matched .)
    Identifier      reduce using rule 20 (statement -> statement_matched .)
    Minus           reduce using rule 20 (statement -> statement_matched .)
    BitNot          reduce using rule 20 (statement -> statement_matched .)
    Not             reduce using rule 20 (statement -> statement_matched .)
    Integer         reduce using rule 20 (statement -> statement_matched .)
    LParen          reduce using rule 20 (statement -> statement_matched .)
    Semi            reduce using rule 20 (statement -> statement_matched .)


state 134

    (21) statement -> statement_unmatched .

    RBrace          reduce using rule 21 (statement -> statement_unmatched .)
    If              reduce using rule 21 (statement -> statement_unmatched .)
    While           reduce using rule 21 (statement -> statement_unmatched .)
    For             reduce using rule 21 (statement -> statement_unmatched .)
    Do              reduce using rule 21 (statement -> statement_unmatched .)
    Continue        reduce using rule 21 (statement -> statement_unmatched .)
    Return          reduce using rule 21 (statement -> statement_unmatched .)
    LBrace          reduce using rule 21 (statement -> statement_unmatched .)
    Break           reduce using rule 21 (statement -> statement_unmatched .)
    Int             reduce using rule 21 (statement -> statement_unmatched .)
    Identifier      reduce using rule 21 (statement -> statement_unmatched .)
    Minus           reduce using rule 21 (statement -> statement_unmatched .)
    BitNot          reduce using rule 21 (statement -> statement_unmatched .)
    Not             reduce using rule 21 (statement -> statement_unmatched .)
    Integer         reduce using rule 21 (statement -> statement_unmatched .)
    LParen          reduce using rule 21 (statement -> statement_unmatched .)
    Semi            reduce using rule 21 (statement -> statement_unmatched .)


state 135

    (41) opt_expression -> expression .

    Semi            reduce using rule 41 (opt_expression -> expression .)
    RParen          reduce using rule 41 (opt_expression -> expression .)


state 136

    (22) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (23) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 149


state 137

    (25) statement_matched -> While . LParen expression RParen statement_matched
    (26) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 150


state 138

    (27) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched

    LParen          shift and go to state 151


state 139

    (38) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 152


state 140

    (33) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (34) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> Do . statement_matched While LParen expression RParen Semi
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    statement_matched              shift and go to state 153
    expression                     shift and go to state 135
    statement_unmatched            shift and go to state 154
    opt_expression                 shift and go to state 139
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 141

    (36) statement_matched -> Continue . Semi

    Semi            shift and go to state 155


state 142

    (37) statement_matched -> Return . expression Semi
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 156
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 143

    (40) statement_matched -> Break . Semi

    Semi            shift and go to state 157


state 144

    (42) opt_expression -> empty .

    Semi            reduce using rule 42 (opt_expression -> empty .)
    RParen          reduce using rule 42 (opt_expression -> empty .)


state 145

    (49) array_sub -> LBracket Integer RBracket . array_sub
    (48) array_sub -> . empty
    (49) array_sub -> . LBracket Integer RBracket array_sub
    (1) empty -> .

    LBracket        shift and go to state 107
    Assign          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    array_sub                      shift and go to state 158
    empty                          shift and go to state 109

state 146

    (43) declaration -> type Identifier . array
    (44) declaration -> type Identifier . array Assign array_expression
    (51) declaration -> type Identifier .
    (52) declaration -> type Identifier . Assign expression
    (50) array -> . LBracket Integer RBracket array_sub

    Semi            reduce using rule 51 (declaration -> type Identifier .)
    Assign          shift and go to state 13
    LBracket        shift and go to state 15

    array                          shift and go to state 12

state 147

    (39) statement_matched -> LBrace block . RBrace
    (16) block -> block . block_item
    (18) block_item -> . statement
    (19) block_item -> . declaration Semi
    (20) statement -> . statement_matched
    (21) statement -> . statement_unmatched
    (43) declaration -> . type Identifier array
    (44) declaration -> . type Identifier array Assign array_expression
    (51) declaration -> . type Identifier
    (52) declaration -> . type Identifier Assign expression
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (2) type -> . Int
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    RBrace          shift and go to state 159
    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    block_item                     shift and go to state 130
    statement                      shift and go to state 131
    declaration                    shift and go to state 132
    statement_matched              shift and go to state 133
    statement_unmatched            shift and go to state 134
    type                           shift and go to state 127
    expression                     shift and go to state 135
    opt_expression                 shift and go to state 139
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 148

    (19) block_item -> declaration Semi .

    RBrace          reduce using rule 19 (block_item -> declaration Semi .)
    If              reduce using rule 19 (block_item -> declaration Semi .)
    While           reduce using rule 19 (block_item -> declaration Semi .)
    For             reduce using rule 19 (block_item -> declaration Semi .)
    Do              reduce using rule 19 (block_item -> declaration Semi .)
    Continue        reduce using rule 19 (block_item -> declaration Semi .)
    Return          reduce using rule 19 (block_item -> declaration Semi .)
    LBrace          reduce using rule 19 (block_item -> declaration Semi .)
    Break           reduce using rule 19 (block_item -> declaration Semi .)
    Int             reduce using rule 19 (block_item -> declaration Semi .)
    Identifier      reduce using rule 19 (block_item -> declaration Semi .)
    Minus           reduce using rule 19 (block_item -> declaration Semi .)
    BitNot          reduce using rule 19 (block_item -> declaration Semi .)
    Not             reduce using rule 19 (block_item -> declaration Semi .)
    Integer         reduce using rule 19 (block_item -> declaration Semi .)
    LParen          reduce using rule 19 (block_item -> declaration Semi .)
    Semi            reduce using rule 19 (block_item -> declaration Semi .)


state 149

    (22) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (23) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> If LParen . expression RParen statement
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 160
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 150

    (25) statement_matched -> While LParen . expression RParen statement_matched
    (26) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 161
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 151

    (27) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (43) declaration -> . type Identifier array
    (44) declaration -> . type Identifier array Assign array_expression
    (51) declaration -> . type Identifier
    (52) declaration -> . type Identifier Assign expression
    (56) expression -> . assignment
    (1) empty -> .
    (2) type -> . Int
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 162
    declaration                    shift and go to state 163
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    type                           shift and go to state 127
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 152

    (38) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 38 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 38 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 38 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 38 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 38 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 38 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 38 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 38 (statement_matched -> opt_expression Semi .)


state 153

    (33) statement_matched -> Do statement_matched . While LParen expression RParen Semi
    (35) statement_unmatched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 164


state 154

    (34) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 165


state 155

    (36) statement_matched -> Continue Semi .

    RBrace          reduce using rule 36 (statement_matched -> Continue Semi .)
    If              reduce using rule 36 (statement_matched -> Continue Semi .)
    While           reduce using rule 36 (statement_matched -> Continue Semi .)
    For             reduce using rule 36 (statement_matched -> Continue Semi .)
    Do              reduce using rule 36 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 36 (statement_matched -> Continue Semi .)
    Return          reduce using rule 36 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 36 (statement_matched -> Continue Semi .)
    Break           reduce using rule 36 (statement_matched -> Continue Semi .)
    Int             reduce using rule 36 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 36 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 36 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 36 (statement_matched -> Continue Semi .)
    Not             reduce using rule 36 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 36 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 36 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 36 (statement_matched -> Continue Semi .)
    Else            reduce using rule 36 (statement_matched -> Continue Semi .)


state 156

    (37) statement_matched -> Return expression . Semi

    Semi            shift and go to state 166


state 157

    (40) statement_matched -> Break Semi .

    RBrace          reduce using rule 40 (statement_matched -> Break Semi .)
    If              reduce using rule 40 (statement_matched -> Break Semi .)
    While           reduce using rule 40 (statement_matched -> Break Semi .)
    For             reduce using rule 40 (statement_matched -> Break Semi .)
    Do              reduce using rule 40 (statement_matched -> Break Semi .)
    Continue        reduce using rule 40 (statement_matched -> Break Semi .)
    Return          reduce using rule 40 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 40 (statement_matched -> Break Semi .)
    Break           reduce using rule 40 (statement_matched -> Break Semi .)
    Int             reduce using rule 40 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 40 (statement_matched -> Break Semi .)
    Minus           reduce using rule 40 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 40 (statement_matched -> Break Semi .)
    Not             reduce using rule 40 (statement_matched -> Break Semi .)
    Integer         reduce using rule 40 (statement_matched -> Break Semi .)
    LParen          reduce using rule 40 (statement_matched -> Break Semi .)
    Semi            reduce using rule 40 (statement_matched -> Break Semi .)
    Else            reduce using rule 40 (statement_matched -> Break Semi .)


state 158

    (49) array_sub -> LBracket Integer RBracket array_sub .

    Assign          reduce using rule 49 (array_sub -> LBracket Integer RBracket array_sub .)
    Semi            reduce using rule 49 (array_sub -> LBracket Integer RBracket array_sub .)


state 159

    (39) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 39 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 39 (statement_matched -> LBrace block RBrace .)


state 160

    (22) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (23) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 167


state 161

    (25) statement_matched -> While LParen expression . RParen statement_matched
    (26) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 168


state 162

    (27) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched

    Semi            shift and go to state 169


state 163

    (28) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched

    Semi            shift and go to state 170


state 164

    (33) statement_matched -> Do statement_matched While . LParen expression RParen Semi
    (35) statement_unmatched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 171


state 165

    (34) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 172


state 166

    (37) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 37 (statement_matched -> Return expression Semi .)
    If              reduce using rule 37 (statement_matched -> Return expression Semi .)
    While           reduce using rule 37 (statement_matched -> Return expression Semi .)
    For             reduce using rule 37 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 37 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 37 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 37 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 37 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 37 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 37 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 37 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 37 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 37 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 37 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 37 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 37 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 37 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 37 (statement_matched -> Return expression Semi .)


state 167

    (22) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (23) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (24) statement_unmatched -> If LParen expression RParen . statement
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (20) statement -> . statement_matched
    (21) statement -> . statement_unmatched
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 135
    statement_matched              shift and go to state 173
    statement_unmatched            shift and go to state 134
    statement                      shift and go to state 174
    opt_expression                 shift and go to state 139
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 168

    (25) statement_matched -> While LParen expression RParen . statement_matched
    (26) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 135
    statement_matched              shift and go to state 175
    statement_unmatched            shift and go to state 176
    opt_expression                 shift and go to state 139
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 169

    (27) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 177
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 170

    (28) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 178
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 171

    (33) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (35) statement_unmatched -> Do statement_matched While LParen . expression RParen Semi
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 179
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 172

    (34) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (56) expression -> . assignment
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 180
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 173

    (22) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (23) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (20) statement -> statement_matched .

    Else            shift and go to state 181
    RBrace          reduce using rule 20 (statement -> statement_matched .)
    If              reduce using rule 20 (statement -> statement_matched .)
    While           reduce using rule 20 (statement -> statement_matched .)
    For             reduce using rule 20 (statement -> statement_matched .)
    Do              reduce using rule 20 (statement -> statement_matched .)
    Continue        reduce using rule 20 (statement -> statement_matched .)
    Return          reduce using rule 20 (statement -> statement_matched .)
    LBrace          reduce using rule 20 (statement -> statement_matched .)
    Break           reduce using rule 20 (statement -> statement_matched .)
    Int             reduce using rule 20 (statement -> statement_matched .)
    Identifier      reduce using rule 20 (statement -> statement_matched .)
    Minus           reduce using rule 20 (statement -> statement_matched .)
    BitNot          reduce using rule 20 (statement -> statement_matched .)
    Not             reduce using rule 20 (statement -> statement_matched .)
    Integer         reduce using rule 20 (statement -> statement_matched .)
    LParen          reduce using rule 20 (statement -> statement_matched .)
    Semi            reduce using rule 20 (statement -> statement_matched .)


state 174

    (24) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)


state 175

    (25) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 25 (statement_matched -> While LParen expression RParen statement_matched .)


state 176

    (26) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 26 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 177

    (27) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched

    Semi            shift and go to state 182


state 178

    (28) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched

    Semi            shift and go to state 183


state 179

    (33) statement_matched -> Do statement_matched While LParen expression . RParen Semi
    (35) statement_unmatched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 184


state 180

    (34) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 185


state 181

    (22) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (23) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    expression                     shift and go to state 135
    statement_matched              shift and go to state 186
    statement_unmatched            shift and go to state 187
    opt_expression                 shift and go to state 139
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 182

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 188
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 183

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 189
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 184

    (33) statement_matched -> Do statement_matched While LParen expression RParen . Semi
    (35) statement_unmatched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 190


state 185

    (34) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 191


state 186

    (22) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 187

    (23) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 188

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched
    (31) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched

    RParen          shift and go to state 192


state 189

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_unmatched
    (32) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched

    RParen          shift and go to state 193


state 190

    (33) statement_matched -> Do statement_matched While LParen expression RParen Semi .
    (35) statement_unmatched -> Do statement_matched While LParen expression RParen Semi .

  ! reduce/reduce conflict for RBrace resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for If resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for While resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for For resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Do resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Continue resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Return resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for LBrace resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Break resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Int resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Identifier resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Minus resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for BitNot resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Not resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Integer resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for LParen resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
  ! reduce/reduce conflict for Semi resolved using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    RBrace          reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 33 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)

  ! RBrace          [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! If              [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! While           [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! For             [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Do              [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Continue        [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Return          [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! LBrace          [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Break           [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Int             [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Identifier      [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Minus           [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! BitNot          [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Not             [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Integer         [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! LParen          [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]
  ! Semi            [ reduce using rule 35 (statement_unmatched -> Do statement_matched While LParen expression RParen Semi .) ]


state 191

    (34) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 34 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 192

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (31) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 139
    statement_matched              shift and go to state 194
    statement_unmatched            shift and go to state 195
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 193

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (32) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (25) statement_matched -> . While LParen expression RParen statement_matched
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (33) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (36) statement_matched -> . Continue Semi
    (37) statement_matched -> . Return expression Semi
    (38) statement_matched -> . opt_expression Semi
    (39) statement_matched -> . LBrace block RBrace
    (40) statement_matched -> . Break Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (26) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (34) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (35) statement_unmatched -> . Do statement_matched While LParen expression RParen Semi
    (41) opt_expression -> . expression
    (42) opt_expression -> . empty
    (56) expression -> . assignment
    (1) empty -> .
    (57) assignment -> . conditional
    (77) assignment -> . refer Assign expression
    (58) conditional -> . logical_or
    (94) conditional -> . logical_or Question expression Colon conditional
    (74) refer -> . Identifier refer_arguments
    (59) logical_or -> . logical_and
    (78) logical_or -> . logical_or Or logical_and
    (60) logical_and -> . bit_or
    (79) logical_and -> . logical_and And bit_or
    (61) bit_or -> . xor
    (80) bit_or -> . bit_or BitOr xor
    (62) xor -> . bit_and
    (81) xor -> . xor Xor bit_and
    (63) bit_and -> . equality
    (82) bit_and -> . bit_and BitAnd equality
    (64) equality -> . relational
    (83) equality -> . equality NotEqual relational
    (84) equality -> . equality Equal relational
    (65) relational -> . additive
    (85) relational -> . relational Less additive
    (86) relational -> . relational Greater additive
    (87) relational -> . relational LessEqual additive
    (88) relational -> . relational GreaterEqual additive
    (66) additive -> . multiplicative
    (89) additive -> . additive Plus multiplicative
    (90) additive -> . additive Minus multiplicative
    (67) multiplicative -> . unary
    (91) multiplicative -> . multiplicative Mul unary
    (92) multiplicative -> . multiplicative Div unary
    (93) multiplicative -> . multiplicative Mod unary
    (68) unary -> . postfix
    (71) unary -> . Minus unary
    (72) unary -> . BitNot unary
    (73) unary -> . Not unary
    (69) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (95) primary -> . Integer
    (96) primary -> . refer
    (97) primary -> . LParen expression RParen

    If              shift and go to state 136
    While           shift and go to state 137
    For             shift and go to state 138
    Do              shift and go to state 140
    Continue        shift and go to state 141
    Return          shift and go to state 142
    LBrace          shift and go to state 128
    Break           shift and go to state 143
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 31
    BitNot          shift and go to state 34
    Not             shift and go to state 35
    Integer         shift and go to state 38
    LParen          shift and go to state 37

    opt_expression                 shift and go to state 139
    statement_matched              shift and go to state 196
    statement_unmatched            shift and go to state 197
    expression                     shift and go to state 135
    empty                          shift and go to state 144
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    refer                          shift and go to state 21
    logical_or                     shift and go to state 22
    logical_and                    shift and go to state 23
    bit_or                         shift and go to state 24
    xor                            shift and go to state 25
    bit_and                        shift and go to state 26
    equality                       shift and go to state 27
    relational                     shift and go to state 28
    additive                       shift and go to state 29
    multiplicative                 shift and go to state 30
    unary                          shift and go to state 32
    postfix                        shift and go to state 33
    primary                        shift and go to state 36

state 194

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .
    (31) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .

  ! reduce/reduce conflict for RBrace resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for If resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for While resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for For resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Do resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Continue resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Return resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for LBrace resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Break resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Int resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Identifier resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Minus resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for BitNot resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Not resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Integer resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for LParen resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Semi resolved using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    RBrace          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)

  ! RBrace          [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! If              [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! While           [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! For             [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Do              [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Continue        [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Return          [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! LBrace          [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Break           [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Int             [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Identifier      [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Minus           [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! BitNot          [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Not             [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Integer         [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! LParen          [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Semi            [ reduce using rule 31 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .) ]


state 195

    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 196

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .
    (32) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .

  ! reduce/reduce conflict for RBrace resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for If resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for While resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for For resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Do resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Continue resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Return resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for LBrace resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Break resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Int resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Identifier resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Minus resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for BitNot resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Not resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Integer resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for LParen resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
  ! reduce/reduce conflict for Semi resolved using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    RBrace          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)

  ! RBrace          [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! If              [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! While           [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! For             [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Do              [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Continue        [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Return          [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! LBrace          [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Break           [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Int             [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Identifier      [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Minus           [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! BitNot          [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Not             [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Integer         [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! LParen          [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]
  ! Semi            [ reduce using rule 32 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .) ]


state 197

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 190 resolved using rule (statement_matched -> Do statement_matched While LParen expression RParen Semi)
WARNING: rejected rule (statement_unmatched -> Do statement_matched While LParen expression RParen Semi) in state 190
WARNING: reduce/reduce conflict in state 194 resolved using rule (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched)
WARNING: rejected rule (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched) in state 194
WARNING: reduce/reduce conflict in state 196 resolved using rule (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched)
WARNING: rejected rule (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched) in state 196
WARNING: Rule (statement_unmatched -> Do statement_matched While LParen expression RParen Semi) is never reduced
WARNING: Rule (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched) is never reduced
WARNING: Rule (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched) is never reduced
